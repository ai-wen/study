# chrome://flags/#block-insecure-private-network-requests
# chrome://version/
Google Chrome	94.0.4606.54 (正式版本) （64 位）
修订版本	c8191a1d5cccbf64e8fe7269043f8ace8d74dd05-refs/branch-heads/4606@{#1130}
操作系统	Windows 10 Version 1809 (Build 17763.316)
JavaScript	V8 9.4.146.16
用户代理	Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.54 Safari/537.36
### 命令行	"C:\Users\lm\AppData\Local\Google\Chrome\Application\chrome.exe" --flag-switches-begin --enable-features=BlockInsecurePrivateNetworkRequests --flag-switches-end
可执行文件路径	C:\Users\lm\AppData\Local\Google\Chrome\Application\chrome.exe
个人资料路径	C:\Users\lm\AppData\Local\Google\Chrome\User Data\Default
其他变体	f475deb0-377be55a
af81735d-ca7d8d80
7e184ca7-ca7d8d80


"C:\Users\lm\AppData\Local\Google\Chrome\Application\chrome.exe" --flag-switches-begin --enable-features=BlockInsecurePrivateNetworkRequests --flag-switches-end
"C:\Users\lm\AppData\Local\Google\Chrome\Application\chrome.exe" --flag-switches-begin --disable-features=BlockInsecurePrivateNetworkRequests --flag-switches-end
"C:\Users\lm\AppData\Local\Google\Chrome\Application\chrome.exe" --flag-switches-begin --flag-switches-end


# [xxxxxxxxxxxxxx](https://wicg.github.io/private-network-access/)

# ![The request client is not a secure context and the resource is in more-private address space `local`](https://web.dev/cors-rfc1918-feedback/)
# [CORS for private networks (RFC1918)](RFC1918.png)

# [blocked by cors policy about CORS-RFC1918](https://blog.csdn.net/MyFreeIT/article/details/120437772)
# [谷歌浏览器配置 chrome://flags/#block-insecure-private-network-requests](CORS.png)

# [CORS 跨域发送 Cookie](https://harttle.land/2016/12/28/cors-with-cookie.html)
在 Web 页面中可以随意地载入跨域的图片、视频、样式等资源， 但 AJAX 请求通常会被浏览器应用同源安全策略，禁止获取跨域数据，以及限制发送跨域请求。 虽然有多种方法利用资源标签进行跨域，但能够进行的数据交互非常有限。 在 2014 年 W3C 发布了 CORS Recommendation 来允许更方便的跨域资源共享。 默认情况下浏览器对跨域请求不会携带 Cookie，但鉴于 Cookie 在身份验证等方面的重要性， CORS 推荐使用额外的响应头字段来允许跨域发送 Cookie。

客户端代码
在open XMLHttpRequest后，设置withCredentials为true即可让该跨域请求携带 Cookie。 注意携带的是目标页面所在域的 Cookie。

var xhr = new XMLHttpRequest();
xhr.open('GET', url);
xhr.withCredentials = true;
xhr.send();
如果你在使用 jQuery，可以通过xhrFields来设置：

$.ajax({
   url: a_cross_domain_url,
   xhrFields: {
      withCredentials: true
   }
});

服务器同时设置Access-Control-Allow-Credentials响应头为"true"， 即可允许跨域请求携带 Cookie。

Access-Control-Allow-Origin
除了Access-Control-Allow-Credentials之外，跨域发送 Cookie 还要求 Access-Control-Allow-Origin不允许使用通配符。 事实上不仅不允许通配符，而且只能指定单一域名：

If the credentials flag is true and the response includes zero or more than one Access-Control-Allow-Credentials header values return fail and terminate this algorithm. –W3C Cross-Origin Resource Sharing
否则，浏览器还是会挡住跨域请求：

计算 Access-Control-Allow-Origin
既然Access-Control-Allow-Origin只允许单一域名， 服务器可能需要维护一个接受 Cookie 的 Origin 列表， 验证 Origin 请求头字段后直接将其设置为Access-Control-Allow-Origin的值。 （这一实践来自 Stackoverflow） 值得注意的是在 CORS 请求被重定向后 Origin 头字段会被置为 null。 此时可以选择从Referer头字段计算得到Origin。

# [踩了Chrome85修改referer策略的坑]()

一个内部使用的网盘系统，同事反馈登录进系统后页面一直在反复刷新，url上的登录token也在疯狂变化。很明显是因为后台没有成功判断到用户已经登录，导致页面一直跳转到登录授权服务器获取token。

这个问题在我到浏览器上也复现了，而我用safari，火狐则没有这个问题。只有Chrome会出现反复刷新。将问题反馈给负责系统后台的同事，神奇的是，他的Chrome并不会反复刷新。

登录同事说登录的token是从登录接口的referer请求头获取的，从日志上看发现我们的请求中referer并没有带上token，只有一个域名。有可能是链接上带的查询参数被Chrome处理掉了。由此，怀疑是Chrome最近有更新才出现了问题。

我查看了我和反馈的同事的Chrome版本是最新的Chrome85，而后台同事的Chrome是77。搜了一下Chrome85的更新内容，发现Chrome真的对请求的referer做了干预。提升了referer的安全性。

referer请求头
开讲referer之前先了解一下 referer 是干什么的：

Referer 请求头包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。服务端一般使用 Referer 请求头识别访问来源，可能会以此进行统计分析、日志记录以及缓存优化等。
———— Referer - MDN - Mozilla

除了请求页面，页面里如果有图片等静态资源和接口请求，这些请求的referer就会是当前页面。比如www.a.com请求了api.a.com/login这个接口，api.a.com/login请求头中的referer就是www.a.com。如果www.a.com后面带了查询字符串，如www.a.com?test=1，则请求参数也会被referer带上，如

// request header
content-length: 4408
content-type: application/json; charset=UTF-8
referer: www.a.com?test=1
Chrome85 的 referer 策略修改
原本默认的 referer 策略（policy）是no-referrer-when-downgrade，即允许referer带上来源页面地址上的请求参数，Chrome85将策略修改为strict-origin-when-cross-origin，即如果请求地址与请求页面非同源，将只携带请求的域名，不会再带上来源页面地址的请求参数。

为什么使用strict-origin-when-cross-origin
增强隐私：使用strict-origin-when-cross-origin将在请求非同源资源的时候，让referer只带上来源页面的源域名，不会暴露链接上的其他参数。

如何开启/关闭no-referrer-when-downgrade
目前只有Chrome85主动使用了no-referrer-when-downgrade这个策略，如果要在其他浏览器开启这个策略，可以分别在前后端做配置：
前端在html页面配置：

<meta name="referrer" content="strict-origin-when-cross-origin" />
服务端可以在请求头上加上 Referer Policy 这个请求头：

Referer Policy: strict-origin-when-cross-origin
关闭strict-origin-when-cross-origin
前端在html设置：

<meta name="referrer" content="no-referrer-when-downgrade"" />
<!-- 对某个特定资源设置 referer 策略 -->
<img src="…" referrerpolicy="no-referrer-when-downgrade" />
服务端将Referer Policy设置为no-referrer-when-downgrade

Referer Policy: no-referrer-when-downgrade
总结
本文介绍了一次referer策略修改引起的系统登录bug，介绍了referer头和如何在前后端调整referer策略以满足开发的需要。
